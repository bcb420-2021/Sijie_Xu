---
title: "BCB420 A1"
output: html_notebook
---

```{r setup, warning=FALSE}

if (!requireNamespace("BiocManager", quietly = TRUE))    
  install.packages("BiocManager")

if (!requireNamespace("GEOmetadb", quietly = TRUE))    
  BiocManager::install("GEOmetadb")

if (!requireNamespace("biomaRt", quietly = TRUE))
  BiocManager::install("biomaRt")

if (!requireNamespace("DBI", quietly = TRUE))
  install.packages("DBI")

if (!requireNamespace("dplyr", quietly = TRUE))
  install.packages("dplyr")

if (!requireNamespace("edgeR", quietly = TRUE))
  install.packages("edgeR")

if (!requireNamespace("limma", quietly = TRUE))
  install.packages("limma")

if (!requireNamespace("ggplot2", quietly = TRUE))
  install.packages("ggplot2")

if (!requireNamespace("tidyr", quietly = TRUE))
  install.packages("tidyr")

if (!requireNamespace("cowplot", quietly = TRUE))
  install.packages("cowplot")

library("dplyr")

```

# Data Exploration

## Find data of interest

```{r find GEO}

# Query for interested data set regarding human from 2016 and beyond

findTopic <- function(keyword, skip = FALSE) {
  
  # Get meta data and setup connection
  if(!file.exists('GEOmetadb.sqlite')) GEOmetadb::getSQLiteFile()
  con <- RSQLite::dbConnect(RSQLite::SQLite(),'GEOmetadb.sqlite')
  
  # Form query
  sql <- paste("SELECT DISTINCT gse.title, gse.gse, gpl.title, gse.submission_date",
   "FROM",
   " gse JOIN gse_gpl ON gse_gpl.gse=gse.gse",
   " JOIN gpl ON gse_gpl.gpl=gpl.gpl",
   "WHERE",
   " gse.title LIKE '%",
   keyword,
   "%' AND",
   " gse.submission_date > '2016-01-01' AND",
   " gpl.organism LIKE '%Homo sapiens%' AND",
   " gpl.technology LIKE '%high-throughput seq%' ",
   sep=" ")
  
  rs <- RSQLite::dbGetQuery(con,sql)
  
  if(!skip) return(rs)
}

#findTopic(keyword = "microRNA") %>% head() %>% knitr::kable(format = "html")


```

## Download dataset GSE89225

```{r download}

# Identify GEO accession
GEO_accession <- "GSE89225"

# Download File if not exist rds file
if (!file.exists("GEO_data.rds")) {
  
  GEO_dir <- paste0("./", GEO_accession)
  
  #Download file from GEO
  sfiles = GEOquery::getGEOSuppFiles(GEO_accession)
  
  # Extract the tar file with txt
  geo_data <- read.csv(rownames(sfiles)[1])
  
  # Save as rds
  saveRDS(object = GEO_data, file = "GEO_data.rds")
  
  # Delete directory
  unlink("GSE89225", recursive = TRUE, force = TRUE)
  
  GEOquery::dbDisconnect(con)
  
} else {
  geo_data <- readRDS("GEO_data.rds")
}

colnames(geo_data) <- c("ensembl_gene_id", colnames(geo_data)[-1])

geo_data[1:5,1:5] %>% knitr::kable(format = "html", caption = "GSE89225 Data Overview")

```



# Data Cleaning

## Basic Cleaning 

```{r data_distribution}

# Unpivot dataset
geo_data_unpivot <- geo_data[,-1] %>% 
  edgeR::cpm() %>% log2() %>%
  as.data.frame() %>% 
  tidyr::gather(key=sample, value=log_cpm) %>% subset(log_cpm > 0)
  
# Density plot
ggplot2::ggplot(geo_data_unpivot, ggplot2::aes(x=log_cpm, color=sample)) +
  ggplot2::geom_density() + ggplot2::labs(title = "Density by sample before Normalization")

# Boxplot
ggplot2::ggplot(geo_data_unpivot, ggplot2::aes(x=sample, y=log_cpm, color=sample)) + 
  ggplot2::geom_boxplot() + ggplot2::coord_flip() + ggplot2::labs(title = "Boxplot by sample before Normalization") + 
  ggplot2::theme(legend.position="none")


```

The two graphs above are density plots, and boxplots of the CPM and log2 transformed data set. A clear bimodal distribution can be seen on the density plot, which is usually associated with BRCA RNA seq data (Bessarabova, 2010). 

```{r basic_cleaning}

# Get the data type matrix
samples <- data.frame(lapply(colnames(geo_data)[-1], FUN=function(x){unlist(strsplit(x, split = "_"))}))
colnames(samples) <- colnames(geo_data)[-1]
rownames(samples) <- c("cell_type","sample_type", "patient")
samples <- data.frame(t(samples))

# Check for NAs within the data set
num_na <- geo_data %>% nrow() - complete.cases(geo_data) %>% sum()

# Check for unique gene id
num_duplicate <- geo_data$ensembl_gene_id %>% unique() %>% length() - geo_data %>% nrow()

# Check for invalid ensemble_gene_id
row_with_ensembl_gene <- grepl(pattern = "ENSG", x = geo_data$ensembl_gene_id) 
geo_data$ensembl_gene_id[!row_with_ensembl_gene] %>% 
  knitr::kable(type = "html", caption = "Abnormal ensembl gene id")

num_invalid <- nrow(geo_data) - length(row_with_ensembl_gene)
geo_data <- geo_data[row_with_ensembl_gene,]
 
# Filter for gene with more than 10 counts
row_sum <- geo_data[-1] %>% rowSums()
outlier_size <- geo_data[which(row_sum < 10),] %>% nrow()

# Remove outliers
geo_data <- geo_data[which(row_sum >= 10),]

```

Three checkers are implemented to check for NA, duplication and invalid ensemble gene id in the data set. The result shows `r num_na` NAs and `r num_duplicate` and `r num_invalid` rows with invalid ensemble gene id, which has been removed from the data set. Additionally, filters are set up to eliminate the genes with a total number of read less than 50 in normal counts. In total, `r outlier_size` number of genes are removed.

## Map data to HGNC

``` {r mapping}

# Create data conversion object
if (!file.exists("ID_conversion.rds")) {

  ensembl <- biomaRt::useMart("ensembl")
  ensembl_haspiens <- biomaRt::useDataset("hsapiens_gene_ensembl", mart=ensembl)
  
  id_conversion <- biomaRt::getBM(attributes = c("ensembl_gene_id","hgnc_symbol"), 
                                  filters = c("ensembl_gene_id"), values = geo_data$ensembl_gene_id, mart = ensembl_haspiens)
  
  saveRDS(id_conversion, "ID_conversion.rds")
  
} else {
  
  id_conversion <- readRDS("ID_conversion.rds")
  
}

# Map the data set to the merge file
geo_data_annot <- merge(id_conversion, geo_data, all.y = TRUE, sort = FALSE)

knitr::kable(geo_data_annot[1:5,1:5], type = "html", caption = "HGNC Mapped Data")

# Inspect lost of data via mapping
ensembl_id_missing_gene <- geo_data_annot$ensembl_gene_id[which(is.na(geo_data_annot$hgnc_symbol) | (geo_data_annot$hgnc_symbol == ""))]
percentage_unmatch <- length(ensembl_id_missing_gene) / nrow(geo_data_annot) * 100
geo_data_annot <- geo_data_annot[which(!is.na(geo_data_annot$hgnc_symbol) & (geo_data_annot$hgnc_symbol != "")),]

knitr::kable(ensembl_id_missing_gene[1:10], type = "html", caption = "Missing HGNC Data")

# Inspect again for duplicated HGNC symbol and delete duplicates
n_occur <- geo_data_annot$hgnc_symbol %>% table() %>% data.frame()
geo_data_annot <- geo_data_annot[geo_data_annot$hgnc_symbol %in% n_occur$.[n_occur$Freq == 1],]

n_occur[n_occur$Freq > 1,] %>% knitr::kable(type = "html", caption = "Duplicated HGNC data")

```

# Data Normalization

```{r normalization}

# Create edgeR object with counts
count_matrix <- as.matrix(geo_data_annot[,-c(1,2)])
rownames(count_matrix) <- geo_data_annot$hgnc_symbol

d = edgeR::DGEList(counts=count_matrix, group=samples$sample_type)

# Calculate normalization factors
geo_data_normalized <- d %>% edgeR::calcNormFactors() %>% edgeR::cpm() %>% as.data.frame()

```

As shown in the data distribution visualization, the data set is in a bimodal distribution. A bimodal distribution like normal distribution follows the central limit theorem, where its sample means is normally distributed. Therefore, I chose to use TTM normalization with edgeR, which allows me to effectively remove batch effect without "over trimming" the original data.  

```{r post_normalization_datavis}

# Unpivot dataset
geo_data_normalized_unpivot <- geo_data_normalized %>% 
  log2() %>% 
  as.data.frame() %>% 
  tidyr::gather(key=sample, value=log_cpm) %>% subset(log_cpm > 0)

# Density plot before and after nor.
density_after <- ggplot2::ggplot(geo_data_normalized_unpivot, ggplot2::aes(x=log_cpm, color=sample)) +
  ggplot2::geom_density() + ggplot2::labs(title = "Density by sample after Normalization") + 
  ggplot2::theme(legend.position="none")

density_before <- ggplot2::ggplot(geo_data_unpivot, ggplot2::aes(x=log_cpm, color=sample)) +
  ggplot2::geom_density() + ggplot2::labs(title = "Density by sample before Normalization") +
  ggplot2::theme(legend.position="none")

cowplot::plot_grid(density_before, density_after, labels = "AUTO")

# Boxplot before and after nor.
box_after <- ggplot2::ggplot(geo_data_normalized_unpivot, ggplot2::aes(x=sample, y=log_cpm, color=sample)) + 
  ggplot2::geom_boxplot() + ggplot2::coord_flip() + ggplot2::labs(title = "Boxplot by sample after Normalization") + 
  ggplot2::theme(legend.position="none")

box_before <- ggplot2::ggplot(geo_data_unpivot, ggplot2::aes(x=sample, y=log_cpm, color=sample)) + 
  ggplot2::geom_boxplot() + ggplot2::coord_flip() + ggplot2::labs(title = "Boxplot by sample before Normalization") + 
  ggplot2::theme(legend.position="none")

cowplot::plot_grid(box_before, box_after, labels = "AUTO")

# Plot MDS
limma::plotMDS(geo_data_annot[,-c(1,2)], 
        labels=samples$sample_type, 
        col = c("red", "dark green")[factor(samples$sample_type)],
        main = "Before Normalization")

limma::plotMDS(geo_data_normalized, 
        labels=samples$sample_type, 
        col = c("red", "dark green")[factor(samples$sample_type)],
        main = "After Normalization")

# Display final data
knitr::kable(geo_data_normalized[1:5,1:5],format = "html", caption = "Normalized data sample")

# Save final data 
if (!file.exists("GEO_data_cleaned.rds")) {
  saveRDS(geo_data_normalized, "GEO_data_cleaned.rds")
}

```
The first plot is a density plot where graph A is the before normalization plot and graph B is the after normalization plot. The TTM eliminated the extreme value on the left end of the plot and made each of the samples' distribution tighten to one another. This means that TTM limits the variation between each sample that is caused by non-biological influencers. 

A similar pattern can be identified by inspecting the boxplots. Each sample shown on the after normalization plot B is more evenly distributed, with less extreme values compare to boxplot A. It is more obvious to look at the lower and upper quantile of each samples, which is noticeably larger.

Eventually, MDS plots echos the observation from the density plot and boxplot. When comparing the before and after normalization MDS, it is noticeable that the NBPs (normal breast parenchyma) samples are more clustering with the tumour samples in the "before" plot, wherein the "after" plot, there is a clear separation between the normal and tumour samples. This is another evidence showing the TTM normalization is eliminating the batch effect.

# Further Discussion

### What are the control and test conditions of the dataset?

The test condition is tumour-resident Treg cells in untreated human breast carcinomas; control conditions are cell conditions in the normal mammary gland and peripheral blood within the parent population.

### Why is the dataset of interest to you?

BRCA is the most common cancer type globally; about 13% of the female population will develop breast cancer during their lifetime (Howlader, 2020), hence it is a topic that is drawing a lot of attention, including mine. I believe that understanding the biological behaviour of tumour-resident Treg cells is essential for the early detection and curing of breast cancer, which is meaningful and beneficial to the community. Additionally, since breast cancer is one of the most studied cancer types, it has relatively large sample sizes and various data sources, making it easier to cross-reference and compare methodology and results. 

### Were there expression values that were not unique for specific genes? How did you handle these?

There is none expression values that is not uniuqe for a specific genes, however, it does included a few of expression values that do not look like a gene which is "__no_feature", "__ambiguous", "__too_low_aQual", "__not_aligne" and "__alignment_not_unique", I decided to delete them from the data set.

### Were there expression values that could not be mapped to current HUGO symbols?

Yes, The HGNC symbol missing portion of the data is taking `r percentage_unmatch`% of the total data set; it is a vast portion of the data. However, because the sample size is large and the data set does not have other gene indicators, query through these genes manually will be complicated. I decided to preserve the gene ensemble id, save it for additional differential expression analysis. If it does show high differential expression, further investigation is required.
 
### How many outliers were removed?

From the density plot and box plot shown at the top of the report, the data's distribution is consistent within each sample. I use a filter to eliminate the genes with a meagre total count of read, with a threshold of 10 (noted the sample size is 34), a total of `r outlier_size` number of genes are removed. 

### How did you handle replicates?

I identified two genes, POLR2J4 and RN7SL274P, which are both pseudogenes that are likely to be regulator RNA segments. Since the study focuses more on the transmembrane cytokine and chemokine receptor gene, I decided to remove the duplicates gene from the data set for simplicity. 

### What is the final coverage of your dataset?

The finial coverage of my data set is number of genes: `r nrow(geo_data_normalized)`, number of samples: `r ncol(geo_data_normalized)`.


## References

Bessarabova, M., Kirillov, E., Shi, W. et al. Bimodal gene expression patterns in breast cancer. BMC Genomics 11, S8 (2010). https://doi.org/10.1186/1471-2164-11-S1-S8

Howlader N, Noone AM, Krapcho M, et al. SEER Cancer Statistics Review, 1975–2017, National Cancer Institute. Bethesda, MD. (2020) https://seer.cancer.gov/csr/1975_2017/

Plitas, G., Konopacki, C., Wu, K., Bos, P. D., Morrow, M., Putintseva, E. V., Chudakov, D. M., & Rudensky, A. Y. (2016). Regulatory T Cells Exhibit Distinct Features in Human Breast Cancer. Immunity, 45(5), 1122–1134. https://doi.org/10.1016/j.immuni.2016.10.032
